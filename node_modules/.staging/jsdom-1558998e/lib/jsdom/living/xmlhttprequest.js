"use strict";

const HTTP_STATUS_CODES = require("http").STATUS_CODES;
const spawnSync = require("child_process").spawnSync;
const URL = require("whatwg-url").URL;
const tough = require("tough-cookie");

const xhrUtils = require("./xhr-utils");
const DOMException = require("../web-idl/DOMException");
const xhrSymbols = require("./xmlhttprequest-symbols");
const blobSymbols = require("./blob-symbols");
const formDataSymbols = require("./form-data-symbols");
const addConstants = require("../utils").addConstants;
const parseContentType = require("./helpers/headers").parseContentType;
const decodeString = require("./helpers/encoding").decodeString;
const normalizeEncoding = require("./helpers/encoding").normalizeEncoding;
const tokenRegexp = require("./helpers/headers").tokenRegexp;
const fieldValueRegexp = require("./helpers/headers").fieldValueRegexp;
const headerListSeparatorRegexp = require("./helpers/headers").headerListSeparatorRegexp;
const documentBaseURLSerialized = require("./helpers/document-base-url").documentBaseURLSerialized;
const idlUtils = require("./generated/utils");
const Document = require("./generated/Document");
const domToHtml = require("../browser/domtohtml").domToHtml;

const syncWorkerFile = require.resolve ? require.resolve("./xhr-sync-worker.js") : null;

const forbiddenRequestHeaders = new Set([
  "accept-charset",
  "accept-encoding",
  "access-control-request-headers",
  "access-control-request-method",
  "connection",
  "content-length",
  "cookie",
  "cookie2",
  "date",
  "dnt",
  "expect",
  "host",
  "keep-alive",
  "origin",
  "referer",
  "te",
  "trailer",
  "transfer-encoding",
  "upgrade",
  "via"
]);
const forbiddenResponseHeaders = new Set([
  "set-cookie",
  "set-cookie2"
]);
const uniqueResponseHeaders = new Set([
  "content-type",
  "content-length",
  "user-agent",
  "referer",
  "host",
  "authorization",
  "proxy-authorization",
  "if-modified-since",
  "if-unmodified-since",
  "from",
  "location",
  "max-forwards"
]);
const corsSafeResponseHeaders = new Set([
  "cache-control",
  "content-language",
  "content-type",
  "expires",
  "last-modified",
  "pragma"
]);


const allowedRequestMethods = new Set(["OPTIONS", "GET", "HEAD", "POST", "PUT", "DELETE"]);
const forbiddenRequestMethods = new Set(["TRACK", "TRACE", "CONNECT"]);

const XMLHttpRequestResponseType = new Set([
  "",
  "arraybuffer",
  "blob",
  "document",
  "json",
  "text"
]);

const simpleHeaders = xhrUtils.simpleHeaders;

const redirectStatuses = new Set([301, 302, 303, 307, 308]);

module.exports = function createXMLHttpRequest(window) {
  const Event = window.Event;
  const ProgressEvent = window.ProgressEvent;
  const Blob = window.Blob;
  const FormData = window.FormData;
  const XMLHttpRequestEventTarget = window.XMLHttpRequestEventTarget;
  const XMLHttpRequestUpload = window.XMLHttpRequestUpload;

  class XMLHttpRequest extends XMLHttpRequestEventTarget {
    constructor() {
      super();
      if (!(this instanceof XMLHttpRequest)) {
        throw new TypeError("DOM object constructor cannot be called as a function.");
      }
      this.upload = new XMLHttpRequestUpload();
      this.upload._ownerDocument = window.document;

      this[xhrSymbols.flag] = {
        synchronous: false,
        withCredentials: false,
        mimeType: null,
        auth: null,
        method: undefined,
        responseType: "",
        requestHeaders: {},
        referrer: this._ownerDocument.URL,
        uri: "",
        timeout: 0,
        body: undefined,
        formData: false,
        preflight: false,
        requestManager: this._ownerDocument._requestManager,
        pool: this._ownerDocument._pool,
        agentOptions: this._ownerDocument._agentOptions,
        strictSSL: this._ownerDocument._strictSSL,
        proxy: this._ownerDocument._proxy,
        cookieJar: this._ownerDocument._cookieJar,
        encoding: this._ownerDocument._encoding,
        origin: this._ownerDocument.origin,
        userAgent: this._ownerDocument._defaultView.navigator.userAgent
      };

      this[xhrSymbols.properties] = {
        beforeSend: false,
        send: false,
        timeoutStart: 0,
        timeoutId: 0,
        timeoutFn: null,
        client: null,
        responseHeaders: {},
        filteredResponseHeaders: [],
        responseBuffer: null,
        responseCache: null,
        responseTextCache: null,
        responseXMLCache: null,
        responseURL: "",
        readyState: XMLHttpRequest.UNSENT,
        status: 0,
        statusText: "",
        error: "",
        uploadComplete: true,
        abortError: false,
        cookieJar: this._ownerDocument._cookieJar
      };
      this.onreadystatechange = null;
    }
    get readyState() {
      return this[xhrSymbols.properties].readyState;
    }
    get status() {
      return this[xhrSymbols.properties].status;
    }
    get statusText() {
      return this[xhrSymbols.properties].statusText;
    }
    get responseType() {
      return this[xhrSymbols.flag].responseType;
    }
    set responseType(responseType) {
      const flag = this[xhrSymbols.flag];
      if (this.readyState === XMLHttpRequest.LOADING || this.readyState === XMLHttpRequest.DONE) {
        throw new DOMException(DOMException.INVALID_STATE_ERR);
      }
      if (this.readyState === XMLHttpRequest.OPENED && flag.synchronous) {
        throw new DOMException(DOMException.INVALID_ACCESS_ERR);
      }
      if (!XMLHttpRequestResponseType.has(responseType)) {
        responseType = "";
      }
      flag.responseType = responseType;
    }
    get response() {
      const flag = this[xhrSymbols.flag];
      const properties = this[xhrSymbols.properties];
      if (properties.responseCache) {
        return properties.responseCache;
      }
      let res = "";
      switch (this.responseType) {
        case "":
        case "text": {
          res = this.responseText;
          break;
        }
        case "arraybuffer": {
          if (!properties.responseBuffer) {
            return null;
          }
          res = (new Uint8Array(properties.responseBuffer)).buffer;
          break;
        }
        case "blob": {
          if (!properties.responseBuffer) {
            return null;
          }
          res = new Blob([(new Uint8Array(properties.responseBuffer)).buffer]);
          break;
        }
        case "document": {
          res = this.responseXML;
          break;
        }
        case "json": {
          if (this.readyState !== XMLHttpRequest.DONE || !properties.responseBuffer) {
            res = null;
          }
          const contentType = getContentType(this);
          const jsonStr = decodeString(properties.responseBuffer, { contentType, defaultEncoding: flag.encoding }).data;
          try {
            res = JSON.parse(jsonStr);
          } catch (e) {
            res = null;
          }
          break;
        }
      }
      properties.responseCache = res;
      return res;
    }
    get responseText() {
      const flag = this[xhrSymbols.flag];
      const properties = this[xhrSymbols.properties];
      if (this.responseType !== "" && this.responseType !== "text") {
        throw new DOMException(DOMException.INVALID_STATE_ERR);
      }
      if (this.readyState !== XMLHttpRequest.LOADING && this.readyState !== XMLHttpRequest.DONE) {
        return "";
      }
      if (properties.responseTextCache) {
        return properties.responseTextCache;
      }
      const responseBuffer = properties.responseBuffer;
      if (!responseBuffer) {
        return "";
      }
      const contentType = getContentType(this);
      const res = decodeString(responseBuffer, { contentType, defaultEncoding: flag.encoding }).data;
      properties.responseTextCache = res;
      return res;
    }
    get responseXML() {
      const flag = this[xhrSymbols.flag];
      const properties = this[xhrSymbols.properties];
      if (this.responseType !== "" && this.responseType !== "document") {
        throw new DOMException(DOMException.INVALID_STATE_ERR);
      }
      if (this.readyState !== XMLHttpRequest.DONE) {
        return null;
      }
      if (properties.responseXMLCache) {
        return properties.responseXMLCache;
      }
      const responseBuffer = properties.responseBuffer;
      if (!responseBuffer) {
        return null;
      }
      const contentType = getContentType(this);
      let isHTML = false;
      let isXML = false;
      if (contentType) {
        isHTML = contentType.isHTML();
        isXML = contentType.isXML();
        if (!isXML && !isHTML) {
          return null;
        }
      }
      const resText = decodeString(responseBuffer, {
        contentType,
        defaultEncoding: flag.encoding,
        detectMetaCharset: true
      });
      if (!resText.data) {
        return null;
      }
      if (this.responseType === "" && isHTML) {
        return null;
      }
      const res = Document.create([], { core: window._core, options: {
        url: flag.uri,
        lastModified: new Date(getResponseHeader(this, "last-modified")),
        parsingMode: isHTML ? "html" : "xml",
        cookieJar: { setCookieSync: () => undefined, getCookieStringSync: () => "" },
        encoding: resText.encoding
      } });
      const resImpl = idlUtils.implForWrapper(res);
      resImpl._htmlToDom.appendHtmlToDocument(resText.data, resImpl);
      res.close();
      properties.responseXMLCache = res;
      return res;
    }

    get responseURL() {
      return this[xhrSymbols.properties].responseURL;
    }

    get timeout() {
      return this[xhrSymbols.flag].timeout;
    }
    set timeout(val) {
      const flag = this[xhrSymbols.flag];
      const properties = this[xhrSymbols.properties];
      if (flag.synchronous) {
        throw new DOMException(DOMException.INVALID_ACCESS_ERR);
      }
      flag.timeout = val;
      clearTimeout(properties.timeoutId);
      if (val > 0 && properties.timeoutFn) {
        properties.timeoutId = setTimeout(
          properties.timeoutFn,
          Math.max(0, val - ((new Date()).getTime() - properties.timeoutStart))
        );
      } else {
        properties.timeoutFn = null;
        properties.timeoutStart = 0;
      }
    }
    get withCredentials() {
      return this[xhrSymbols.flag].withCredentials;
    }
    set withCredentials(val) {
      const flag = this[xhrSymbols.flag];
      const properties = this[xhrSymbols.properties];
      if (!(this.readyState === XMLHttpRequest.UNSENT || this.readyState === XMLHttpRequest.OPENED)) {
        throw new DOMException(DOMException.INVALID_STATE_ERR);
      }
      if (properties.send) {
        throw new DOMException(DOMException.INVALID_STATE_ERR);
      }
      flag.withCredentials = val;
    }

    abort() {
      const flag = this[xhrSymbols.flag];
      const properties = this[xhrSymbols.properties];
      if (properties.beforeSend) {
        throw new DOMException(DOMException.INVALID_STATE_ERR);
      }
      clearTimeout(properties.timeoutId);
      properties.timeoutFn = null;
      properties.timeoutStart = 0;
      const client = properties.client;
      if (client) {
        client.abort();
      }
      if (!(this.readyState === XMLHttpRequest.UNSENT ||
          (this.readyState === XMLHttpRequest.OPENED && !properties.send) ||
          this.readyState === XMLHttpRequest.DONE)) {
        properties.send = false;
        readyStateChange(this, XMLHttpRequest.DONE);
        if (!(flag.method === "HEAD" || flag.method === "GET")) {
          this.upload.dispatchEvent(new ProgressEvent("progress"));
          this.upload.dispatchEvent(new ProgressEvent("abort"));
          if (properties.abortError) {
            this.upload.dispatchEvent(new ProgressEvent("error"));
          }
          this.upload.dispatchEvent(new ProgressEvent("loadend"));
        }
        this.dispatchEvent(new ProgressEvent("progress"));
        this.dispatchEvent(new ProgressEvent("abort"));
        if (properties.abortError) {
          this.dispatchEvent(new ProgressEvent("error"));
        }
        this.dispatchEvent(new ProgressEvent("loadend"));
      }
      properties.readyState = XMLHttpRequest.UNSENT;
    }
    getAllResponseHeaders() {
      const properties = this[xhrSymbols.properties];
      const readyState = this.readyState;
      if (readyState === XMLHttpRequest.UNSENT || readyState === XMLHttpRequest.OPENED) {
        return "";
      }
      return Object.keys(properties.responseHeaders)
        .filter(key => properties.filteredResponseHeaders.indexOf(key) === -1)
        .map(key => [key, properties.responseHeaders[key]].join(": ")).join("\r\n");
    }

    getResponseHeader(header) {
      const properties = this[xhrSymbols.properties];
      const readyState = this.readyState;
      if (readyState === XMLHttpRequest.UNSENT || readyState === XMLHttpRequest.OPENED) {
        return null;
      }
      const lcHeader = toByteString(header).toLowerCase();
      if (properties.filteredResponseHeaders.find(filtered => lcHeader === filtered.toLowerCase())) {
        return null;
      }
      return getResponseHeader(this, lcHeader);
    }

    open(method, uri, asynchronous, user, password) {
      if (!this._ownerDocument) {
        throw new DOMException(DOMException.INVALID_STATE_ERR);
      }
      const flag = this[xhrSymbols.flag];
      const properties = this[xhrSymbols.properties];
      const argumentCount = arguments.length;
      if (argumentCount < 2) {
        throw new TypeError("Not enought arguments");
      }
      method = toByteString(method);
      if (!tokenRegexp.test(method)) {
        throw new DOMException(DOMException.SYNTAX_ERR);
      }
      const upperCaseMethod = method.toUpperCase();
      if (forbiddenRequestMethods.has(upperCaseMethod)) {
        throw new DOMException(DOMException.SECURITY_ERR);
      }

      const client = properties.client;
      if (client && typeof client.abort === "function") {
        client.abort();
      }

      if (allowedRequestMethods.has(upperCaseMethod)) {
        method = upperCaseMethod;
      }
      if (typeof asynchronous !== "undefined") {
        flag.synchronous = !asynchronous;
      } else {
        flag.synchronous = false;
      }
      if (flag.responseType && flag.synchronous) {
        throw new DOMException(DOMException.INVALID_ACCESS_ERR);
      }
      if (flag.synchronous && flag.timeout) {
        throw new DOMException(DOMException.INVALID_ACCESS_ERR);
      }
      flag.method = method;

      let urlObj;
      try {
        urlObj = new URL(uri, documentBaseURLSerialized(this._ownerDocument));
      } catch (e) {
        throw new DOMException(DOMException.SYNTAX_ERR);
      }

      if (user || (password && !urlObj.username)) {
        flag.auth = {
          user,
          pass: password
        };
        urlObj.username = "";
        urlObj.password = "";
      }

      flag.uri = urlObj.href;
      flag.requestHeaders = {};
      flag.preflight = false;

      properties.send = false;
      properties.requestBuffer = null;
      properties.requestCache = null;
      properties.abortError = false;
      properties.responseURL = "";
      readyStateChange(this, XMLHttpRequest.OPENED);
    }

    overrideMimeType(mime) {
      const readyState = this.readyState;
      if (readyState === XMLHttpRequest.LOADING || readyState === XMLHttpRequest.DONE) {
        throw new DOMException(DOMException.INVALID_STATE_ERR);
      }
      if (!mime) {
        throw new DOMException(DOMException.SYNTAX_ERR);
      }
      mime = String(mime);
      if (!parseContentType(mime)) {
        throw new DOMException(DOMException.SYNTAX_ERR);
      }
      this[xhrSymbols.flag].mimeType = mime;
    }

    send(body) {
      if (!this._ownerDocument) {
        throw new DOMException(DOMException.INVALID_STATE_ERR);
      }
      const flag = this[xhrSymbols.flag];
      const properties = this[xhrSymbols.properties];

      if (this.readyState !== XMLHttpRequest.OPENED || properties.send) {
        throw new DOMException(DOMException.INVALID_STATE_ERR);
      }

      properties.beforeSend = true;

      try {
        if (!flag.body &&
            body !== undefined &&
            body !== null &&
            body !== "" &&
            !(flag.method === "HEAD" || flag.method === "GET")) {
          if (body instanceof FormData) {
            flag.formData = true;
            const formData = [];
            for (const entry of body[formDataSymbols.entries]) {
              let val;
              if (entry.value instanceof Blob) {
                const blob = entry.value;
                val = {
                  name: entry.name,
                  value: blob[blobSymbols.buffer],
                  options: {
                    filename: blob.name,
                    contentType: blob.type,
                    knownLength: blob.size
                  }
                };
              } else {
                val = entry;
              }
              formData.push(val);
            }
            flag.body = formData;
          } else if (body instanceof Blob) {
            flag.body = body[blobSymbols.buffer];
          } else if (body instanceof ArrayBuffer) {
            flag.body = new Buffer(new Uint8Array(body));
          } else if (body instanceof Document.interface) {
            if (body.childNodes.length === 0) {
              throw new DOMException(DOMException.INVALID_STATE_ERR);
            }
            flag.body = 